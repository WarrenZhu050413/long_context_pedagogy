#!/usr/bin/env python3
"""
Claude CLI Processor - Handles subprocess execution of claude -p commands
"""

import asyncio
import subprocess
import json
import shlex
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional


class ClaudeCLIProcessor:
    """Process tasks using claude -p command in bash"""
    
    def __init__(self, results_dir: str = "~/async"):
        self.results_dir = Path(results_dir).expanduser()
        self.results_dir.mkdir(parents=True, exist_ok=True)
        
        # Model mapping for CLI
        self.MODEL_FLAGS = {
            "sonnet": "--model sonnet",
            "opus": "--model opus"
        }
        
        # Concise personality prompt
        self.SYSTEM_PROMPT = """Be concise and informative (200-500 words).
Use clear structure with bullet points.
Focus on key insights, not exhaustive details.
End with a 1-2 sentence summary."""
    
    async def process_with_claude_cli(
        self, 
        task_id: str, 
        query: str, 
        model: str = "sonnet"
    ) -> Dict:
        """Execute claude -p command via subprocess"""
        
        # Prepare the prompt with personality
        full_prompt = f"{self.SYSTEM_PROMPT}\n\nQuery: {query}"
        
        # Build claude command
        model_flag = self.MODEL_FLAGS.get(model, self.MODEL_FLAGS["sonnet"])
        
        # Escape the prompt for bash
        escaped_prompt = shlex.quote(full_prompt)
        
        # Full command
        cmd = f"claude {model_flag} -p {escaped_prompt}"
        
        # Log the command (without the full prompt for brevity)
        self._log(f"Executing: claude {model_flag} -p [query for task {task_id}]")
        
        try:
            # Run claude CLI command
            process = await asyncio.create_subprocess_shell(
                cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                shell=True
            )
            
            # Wait for completion with timeout
            timeout_minutes = 5 if model != "opus" else 10
            stdout, stderr = await asyncio.wait_for(
                process.communicate(), 
                timeout=timeout_minutes * 60
            )
            
            if process.returncode == 0:
                # Success - save result
                result = stdout.decode('utf-8')
                await self._save_result(task_id, query, model, result)
                
                return {
                    "status": "completed",
                    "result": result[:500],  # Preview
                    "full_result_path": f"~/async/{datetime.now().strftime('%Y-%m-%d')}/{task_id}.md"
                }
            else:
                # Error occurred
                error = stderr.decode('utf-8')
                self._log(f"Error for task {task_id}: {error}")
                
                return {
                    "status": "failed",
                    "error": error[:500]  # Truncate error message
                }
                
        except asyncio.TimeoutError:
            self._log(f"Timeout for task {task_id} after {timeout_minutes} minutes")
            return {
                "status": "failed",
                "error": f"Claude CLI timeout after {timeout_minutes} minutes"
            }
        except Exception as e:
            self._log(f"Exception for task {task_id}: {str(e)}")
            return {
                "status": "failed",
                "error": str(e)[:500]
            }
    
    async def _save_result(
        self, 
        task_id: str, 
        query: str, 
        model: str, 
        result: str
    ):
        """Save result to organized structure"""
        # Create organized directory structure
        date_str = datetime.now().strftime("%Y-%m-%d")
        task_dir = self.results_dir / date_str
        task_dir.mkdir(parents=True, exist_ok=True)
        
        # Save result as markdown
        result_file = task_dir / f"{task_id}.md"
        content = f"""# Async Query Result

**Task ID**: {task_id}
**Model**: {model}
**Date**: {datetime.now().isoformat()}

## Query
{query}

## Response

{result}

---
*Generated by Async MCP Server using Claude CLI*
"""
        
        result_file.write_text(content)
        self._log(f"Result saved: {result_file}")
        
        # Update index
        await self._update_index(task_id, query, model, result_file)
    
    async def _update_index(
        self, 
        task_id: str, 
        query: str, 
        model: str, 
        result_path: Path
    ):
        """Update index file with new result"""
        index_file = self.results_dir / "index.json"
        
        # Load existing index
        if index_file.exists():
            with open(index_file) as f:
                index = json.load(f)
        else:
            index = {"tasks": [], "metadata": {"total_tasks": 0}}
        
        # Add new entry
        index["tasks"].append({
            "task_id": task_id,
            "query": query[:100] + ("..." if len(query) > 100 else ""),
            "model": model,
            "timestamp": datetime.now().isoformat(),
            "result_path": str(result_path.relative_to(self.results_dir))
        })
        
        # Update metadata
        index["metadata"]["total_tasks"] = len(index["tasks"])
        index["metadata"]["last_updated"] = datetime.now().isoformat()
        
        # Keep only last 100 tasks in index
        if len(index["tasks"]) > 100:
            index["tasks"] = index["tasks"][-100:]
        
        # Save updated index
        with open(index_file, 'w') as f:
            json.dump(index, f, indent=2)
        
        self._log(f"Index updated with task {task_id}")
    
    def _log(self, message: str):
        """Log to stderr for Docker logs"""
        import sys
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"[CLI][{timestamp}] {message}", file=sys.stderr)
